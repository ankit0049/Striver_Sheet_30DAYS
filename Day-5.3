Approach 1 : 
We Take An Extra LinkedList ans 

and we put the pointer head1 on first ls and head2 at second
ls and we check whose value is lesser 
just take that and store in our ans . and increase
their respecctive pointer. 
if any onr got null so we push direct the remaining one .


( this is like Mergersort => merge Function) 



Approach 2 :

Step 1: Create two pointers, say l1 and l2. Compare the first node of both lists and find the small among the two. 
 Assign pointer l1 to the smaller value node.

Step 2: Create a pointer, say res, to l1. An iteration is
 basically iterating through both lists till the value pointed by l1 is less than or equal to the value pointed by l2.

Step 3: Start iteration. Create a variable, say, temp. It will 
keep track of the last node sorted list in an iteration. 

Step 4: Once an iteration is complete, link node pointed by
 temp to node pointed by l2. Swap l1 and l2.

Step 5: If any one of the pointers among l1 and l2 is NULL,
 then move the node pointed by temp to the next higher value node.   




 
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) return l2; 
        if(l2 == null) return l1;
        
        if(l1.val > l2.val) {
            ListNode temp = l1;
            l1 = l2;
            l2 = temp;
        }
        
        ListNode res = l1;

        while(l1 != null && l2 != null) {
            ListNode temp = null;

            while(l1 != null && l1.val <= l2.val) {
                temp = l1;
                l1 = l1.next;
            }

            temp.next = l2;
            ListNode swap = l1;
            l1 = l2;
            l2 = swap;
        }

        return res;
    }
