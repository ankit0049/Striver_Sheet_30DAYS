Approach-1  

Use tow Pointer check whose value is less then  consider 
in our Array . and increse repectively their pointer. 
this going to takes  
(o(n+m) space extra then takes more time complexity 
into seprate them  )

Approach-2  
again consider 2 pointer left & right and 
check if arr left>right then swap 
  swap(arr[left], arr[right-n]) 
  then sort the seprate Array  
 
 i.e => [1,7 ,9] , [3 ,2 ,20] 

left=0 right=0 
arr[left] = 1 & arr[right]=3 condition false 
left++;
then arr[left] =7 & arr[right] = 3(true swap) 
left++ ; right++ 
then 
arr[left] =9 & arr[right]=2  (true ,swap)
left++; right++
if anyone reach length loop break so here 
loop break; 
[1,3,2] [7,9,20]  => sort both & get the Output

Approach-3 
Using The Shell sort Gap Technique 
we have 2 Array length respectively n & m 
we add them and divide by 2 & take ceil one that is the 
gap we check the arr[i]>arr[i+gap](logically (syntactically not)) 
if true then swap until loop break again we divide by 2 gap 
then check until repeat the gap become 0.
if gap become 0 means we get desired output
 
 Approach-3 code Below 


Public static void Approach3(int arr1[] , int arr2[] , int m , int n)
{
    int gap = (int) Math.ceil((n + m) / 2.0);

   
    while(gap!=0)
    {      int left = 0;
            int right = left + gap;
            while (right < len) {
                // case 1: left in arr1[]
                //and right in arr2[]:
                if (left < n && right >= n) {
                    swapIfGreater(arr1, arr2, left, right - n);
                }
                // case 2: both pointers in arr2[]:
                else if (left >= n) {
                    swapIfGreater(arr2, arr2, left - n, right - n);
                }
                // case 3: both pointers in arr1[]:
                else {
                    swapIfGreater(arr1, arr1, left, right);
                }
                left++; right++;
            }
            // break if iteration gap=1 is completed:
            if (gap == 1) break;

            // Otherwise, calculate new gap:
       gap= (int)Math.ceil(gap/2.0);
    }
} 


public static void swapIfGreater(long[] arr1, long[] arr2, int ind1, int ind2) {
        if (arr1[ind1] > arr2[ind2]) {
            long temp = arr1[ind1];
            arr1[ind1] = arr2[ind2];
            arr2[ind2] = temp;
        }
    }