Approach 1 : 
Brute Force Approach  We use 4 loop and check 
all 4 possible index that make target 
and store in set so that not contain any duplicate 


Approach 2 :
to Better Approach we Use 3 loop for sum of the 
3 element and check the remain one element is in 
the hashset or not if contain then we take that's
group of element that makes the target .
but here one issue :
[1 ,2 ,6 , 4 ]  target=10 
starting three element sum=9 
we check (target-sum) contains it gives true .
because 1 is present in Set . 
We can use One element only once.

For the resolve this Issue  
we take 3 pointers 
(i -> n) and j=>(i+1 to n) k=>(n-1 to >j)

we take element in hashset . between the j & k 
this method resolve the issue.

for(i=0 to n)
{
    for(j=i+1 to n)
    {
        for( k = j+1 to n)
        {
            sum = arr(i+j+k);
            if(hashset.contains(target-sum))
            {
                arraylist.add({i,j,k,target-sum});
                Unique.add(arraylist)
            } 
            hashset.add(arr[k]);
        }
    }
} 

Approach 3 : 
First we Sort The Array 
and use 3 Pointer i , j , k  , l
i=0 j=i+1 , k=j+1 ,l = n-1; 
here i & j is fixed we check if sum of all index 
is greater the we decrese l-- if less then increse
the k++ else that the possible ans so store that
likewise Execute The All & we got the Final Output


Approach 3 Code Given  Below  :  
Don't Run Blindly .check compilation then use .

Public static void 4Sum(int arr[] , int target)
{  List<List<Integer>> Ans = new Arraylist();
    int n = arr.length;
    for(int i =0; i<n ; i++)
    { if(i>0 && arr[i]==arr[i-1]) continue;
        for(int j =i+1; j<n ; j++)
        {  
            if(arr[j]==arr[j-1]) continue;

            int k = j+1;
            int l = n-1;
            while(k<l)
            {
                int sum = arr[i]+arr[j]+arr[k]+arr[l];
                if(sum>0) l--;
                else if(sum<0) k--;
                else 
                {
                    Ans.add({arr[i], arr[j] , arr[k] , arr[l]}); 
                    k++;
                    l--; 

                    while(k<l && arr[k]==arr[k-1]) k++;
                    while(k<l && arr[l]==arr[l+1]) l--;

                }
            }
        }
    } 
    return ans;
}